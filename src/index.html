<!DOCTYPE html>
<html>
  <head>
    <base target="_top" />
    <script src="https://cdn.tailwindcss.com"></script>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
      /* Simple loader (unchanged) */
      #loader {
        border: 8px solid #f3f3f3;
        border-top: 8px solid #3498db;
        border-radius: 50%;
        width: 60px;
        height: 60px;
        animation: spin 2s linear infinite;
        position: absolute;
        top: 40%;
        left: 45%;
      }
      #loader-text {
        position: absolute;
        top: 50%;
        left: 40%;
        margin-top: 50px;
        color: #333;
        font-family: sans-serif;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
      .hidden {
        display: none;
      }
    </style>
  </head>
  <body class="bg-gray-100 font-sans p-4 sm:p-8">
    <div id="loader-container">
      <div id="loader"></div>
      <div id="loader-text">Loading data...</div>
    </div>

    <div id="app-content" class="max-w-7xl mx-auto hidden">
      <h1 class="text-3xl font-bold text-gray-800 mb-6">
        Library Complexity Dashboard
      </h1>

      <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-6">
        <div class="lg:col-span-1 bg-white p-6 rounded-lg shadow-md">
          <h2 class="text-xl font-semibold text-gray-700 mb-4">
            Make a Prediction
          </h2>
          <p class="text-sm text-gray-600 mb-4">
            Select the conditions to predict the library's status based on
            historical data.
          </p>

          <div class="space-y-4">
            <div>
              <label
                for="filter-location"
                class="block text-sm font-medium text-gray-700"
                >Location</label
              >
              <select
                id="filter-location"
                class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"
              ></select>
            </div>
            <div>
              <label
                for="filter-day"
                class="block text-sm font-medium text-gray-700"
                >Day of Week</label
              >
              <select
                id="filter-day"
                class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"
              ></select>
            </div>
            <div>
              <label
                for="filter-hour"
                class="block text-sm font-medium text-gray-700"
                >Hour (24-hour)</label
              >
              <select
                id="filter-hour"
                class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"
              ></select>
            </div>
          </div>

          <button
            id="predict-button"
            class="mt-6 w-full bg-indigo-600 text-white py-2 px-4 rounded-md shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
          >
            Predict Status
          </button>

          <div
            id="prediction-result"
            class="mt-6 p-4 bg-gray-50 rounded-md hidden"
          >
            <h3 class="text-lg font-semibold text-gray-800">Prediction:</h3>
            <p id="result-text" class="text-xl text-center font-bold"></p>
            <p
              id="result-subtext"
              class="text-sm text-center text-gray-600"
            ></p>
          </div>
        </div>

        <div class="lg:col-span-2 bg-white p-6 rounded-lg shadow-md">
          <h2 class="text-xl font-semibold text-gray-700 mb-4">
            Average Complexity by Hour
          </h2>
          <p class="text-sm text-gray-600 mb-4">
            This line chart shows the overall library "rhythm." It's the average
            percentage of locations marked "Moderate" (보통) or "Congested"
            (혼잡) at any given hour.
          </p>

          <div id="timeseries-chart-div" class="w-full h-96">
            <canvas id="timeSeriesCanvas"></canvas>
          </div>

          <p id="timeseries-chart-error" class="text-red-500 hidden"></p>
        </div>
      </div>

      <div class="bg-white p-6 rounded-lg shadow-md">
        <h2 class="text-xl font-semibold text-gray-700 mb-4">
          Historical Status by Location
        </h2>
        <p class="text-sm text-gray-600 mb-4">
          This chart shows the total counts of all three statuses recorded for
          each location.
        </p>

        <div id="barchart-div" class="w-full">
          <canvas id="barChartCanvas"></canvas>
        </div>
        <p id="barchart-error" class="text-red-500 hidden"></p>
      </div>
    </div>

    <script>
      let globalData = null;

      // 3. REMOVED: Google Charts loaders
      // google.charts.load("current", { packages: ["corechart", "bar"] });
      // google.charts.setOnLoadCallback(loadData);

      function loadData() {
        console.log("Requesting data from server...");
        google.script.run
          .withSuccessHandler(onDataLoaded)
          .withFailureHandler(onFailure)
          .getSheetData();
      }

      function onDataLoaded(data) {
        console.log("Data received from server:", data);

        if (data.error) {
          onFailure({ message: data.error });
          return;
        }

        if (
          !data.filters ||
          !data.filters.locations ||
          data.filters.locations.length === 0
        ) {
          onFailure({
            message:
              "No data was processed. Please check your spreadsheet data format and Apps Script logs for errors.",
          });
          return;
        }

        globalData = data;

        populateSelect("filter-location", data.filters.locations);
        populateSelect("filter-day", data.filters.days);

        const formattedHours = data.filters.hours.map((h) => {
          const hourStr = String(h).padStart(2, "0");
          return { value: h, text: `${hourStr}:00` };
        });
        populateSelect("filter-hour", formattedHours, true);

        try {
          const now = new Date();
          const dayNames = [
            "Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday",
          ];
          const currentDayName = dayNames[now.getDay()];
          const daySelect = document.getElementById("filter-day");
          if (data.filters.days.includes(currentDayName)) {
            daySelect.value = currentDayName;
          }

          const currentHour = now.getHours();
          const targetHour = (currentHour + 1) % 24;
          const hourSelect = document.getElementById("filter-hour");

          if (data.filters.hours.includes(targetHour)) {
            hourSelect.value = targetHour;
          } else if (data.filters.hours.includes(currentHour)) {
            hourSelect.value = currentHour;
          }
        } catch (e) {
          console.error("Could not set default day/hour:", e);
        }

        // Call the new Chart.js functions
        drawBarChart(data.barChartData);
        drawTimeSeriesChart(data.timeSeriesChartData);

        document.getElementById("loader-container").classList.add("hidden");
        document.getElementById("app-content").classList.remove("hidden");
        document
          .getElementById("predict-button")
          .addEventListener("click", handlePrediction);
      }

      function populateSelect(elementId, options, isObject = false) {
        // ... (This function is unchanged)
        const select = document.getElementById(elementId);
        select.innerHTML = "";

        if (options.length === 0) {
          select.innerHTML = "<option>No options</option>";
          return;
        }

        options.forEach((option) => {
          const opt = document.createElement("option");
          if (isObject) {
            opt.value = option.value;
            opt.textContent = option.text;
          } else {
            opt.value = option;
            opt.textContent = option;
          }
          select.appendChild(opt);
        });
      }

      /**
       * 4. REWRITTEN: Draws the Bar Chart with Chart.js
       */
      function drawBarChart(chartData) {
        if (!chartData || chartData.length <= 1) {
          document.getElementById("barchart-error").textContent =
            "No data for Bar Chart.";
          document.getElementById("barchart-error").classList.remove("hidden");
          return;
        }

        // --- This is your dynamic height calculation (unchanged) ---
        // It works by setting the height of the PARENT div.
        const numberOfRows = chartData.length - 1; // -1 for header row
        const rowHeight = 30; // 30px per bar (you can adjust this)
        const chartChromeHeight = 120; // Extra space for title, legend, axis
        const newHeight = numberOfRows * rowHeight + chartChromeHeight;

        const chartDiv = document.getElementById("barchart-div");
        chartDiv.style.height = newHeight + "px";
        // --- End of dynamic height calculation ---

        // Process data for Chart.js
        const labels = [];
        const smoothData = [];
        const moderateData = [];
        const congestedData = [];

        // Start at 1 to skip header row
        for (let i = 1; i < chartData.length; i++) {
          labels.push(chartData[i][0]);
          smoothData.push(chartData[i][1]);
          moderateData.push(chartData[i][2]);
          congestedData.push(chartData[i][3]);
        }

        // Get the canvas
        const ctx = document.getElementById("barChartCanvas").getContext("2d");

        new Chart(ctx, {
          type: "bar",
          data: {
            labels: labels,
            datasets: [
              {
                label: "Smooth", // Corresponds to chartData[0][1]
                data: smoothData,
                backgroundColor: "#6EE7B7", // Your original color
              },
              {
                label: "Moderate", // Corresponds to chartData[0][2]
                data: moderateData,
                backgroundColor: "#FBBF24", // Your original color
              },
              {
                label: "Congested", // Corresponds to chartData[0][3]
                data: congestedData,
                backgroundColor: "#EF4444", // Your original color
              },
            ],
          },
          options: {
            indexAxis: "y", // This makes it a horizontal bar chart
            responsive: true, // This makes it fill the container
            maintainAspectRatio: false, // IMPORTANT: This lets it fill the dynamic height
            scales: {
              x: {
                stacked: true, // Stacks the bars
                title: { display: true, text: "Total Count" },
              },
              y: {
                stacked: true, // Stacks the bars
                title: { display: true, text: "Location" },
              },
            },
            plugins: {
              title: {
                display: true,
                text: "Status Counts by Location",
              },
            },
          },
        });
      }

      /**
       * 5. REWRITTEN: Draws the Time Series Line Chart with Chart.js
       */
      function drawTimeSeriesChart(chartData) {
        if (!chartData || chartData.length <= 1) {
          document.getElementById("timeseries-chart-error").textContent =
            "No data for Time Series Chart.";
          document
            .getElementById("timeseries-chart-error")
            .classList.remove("hidden");
          return;
        }

        // --- Process data for Chart.js ---
        const labels = [];
        const percentageData = [];

        for (let i = 1; i < chartData.length; i++) {
          const hour = chartData[i][0];
          const percentage = chartData[i][1];
          labels.push(hour);

          if (percentage === 0) {
            percentageData.push(null);
          } else {
            percentageData.push(percentage);
          }
        }

        // --- NEW: DYNAMIC Y-AXIS CALCULATION ---

        // 1. Find the highest data point (filtering out 'null' values)
        const dataMax = Math.max(...percentageData.filter((v) => v !== null));

        // 2. Calculate a new ceiling, 10% above the max, rounded to the nearest 10.
        // (e.g., if max is 30, new ceiling is 40. If max is 32, new ceiling is 50)
        let newYAxisMax = Math.ceil(dataMax / 10) * 10 + 10;

        // 3. Ensure the max is never more than 100
        newYAxisMax = Math.min(newYAxisMax, 100);

        // --- END OF NEW CALCULATION ---

        const ctx = document
          .getElementById("timeSeriesCanvas")
          .getContext("2d");

        new Chart(ctx, {
          type: "line",
          data: {
            labels: labels,
            datasets: [
              {
                label: "Not Smooth %",
                data: percentageData,
                borderColor: "#4F46E5", // Your original color
                backgroundColor: "#4F46E5",
                fill: false,
                tension: 0.1, // Makes the line slightly curved
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false, // Fills the h-96 div
            scales: {
              x: {
                title: { display: true, text: "Hour of Day" },
              },
              y: {
                title: { display: true, text: "Not Smooth % (Mod/Congested)" },
                min: 0,
                // 4. Use the new dynamic max instead of 100
                max: newYAxisMax,
                // Adds the '%' symbol to the Y-axis ticks
                ticks: {
                  callback: function (value, index, values) {
                    return value + "%";
                  },
                },
              },
            },
            plugins: {
              legend: {
                display: false, // Hides the legend
              },
              title: {
                display: true,
                text: "Average Library Complexity by Hour",
              },
            },
          },
        });
      }
      /**
       * Handles the prediction logic (unchanged)
       */
      function handlePrediction() {
        // ... (This function is unchanged)
        const location = document.getElementById("filter-location").value;
        const day = document.getElementById("filter-day").value;
        const hour = document.getElementById("filter-hour").value;

        const modelKey = `${location}|${day}|${hour}`;

        const resultDiv = document.getElementById("prediction-result");
        const resultText = document.getElementById("result-text");
        const resultSubtext = document.getElementById("result-subtext");

        if (!globalData || !globalData.predictionModel) {
          onFailure({ message: "Prediction model not loaded." });
          return;
        }

        const modelEntry = globalData.predictionModel[modelKey];

        if (modelEntry) {
          const statuses = [
            {
              name: "혼잡 (Congested)",
              count: modelEntry["혼잡"],
              color: "text-red-600",
            },
            {
              name: "보통 (Moderate)",
              count: modelEntry["보통"],
              color: "text-yellow-600",
            },
            {
              name: "원활 (Smooth)",
              count: modelEntry["원활"],
              color: "text-green-600",
            },
          ];

          statuses.sort((a, b) => b.count - a.count);
          const bestPrediction = statuses[0];

          const probability = (bestPrediction.count / modelEntry.total) * 100;

          resultText.textContent = bestPrediction.name;
          resultText.className = `text-xl text-center font-bold ${bestPrediction.color}`;
          resultSubtext.textContent = `Based on ${
            modelEntry.total
          } data points, there's a ${Math.round(
            probability
          )}% chance of this status.`;
        } else {
          resultText.textContent = "No Data";
          resultText.className = "text-xl text-center font-bold text-gray-500";
          resultSubtext.textContent =
            "We have no historical data for this specific combination.";
        }

        resultDiv.classList.remove("hidden");
      }

      function onFailure(error) {
        // ... (This function is unchanged)
        console.error("Failed to load:", error);
        const loaderContainer = document.getElementById("loader-container");
        loaderContainer.innerHTML = `<div class="text-red-600 font-bold p-8 bg-white rounded shadow-md">Error: ${error.message}. <br><br>Please check the following: <br>1. The spreadsheet name is exactly 'SJCityLib'. <br>2. The sheet name is exactly 'Complexity'. <br>3. Check the Apps Script "Executions" log for more details.</div>`;
      }

      // 6. ADDED: This starts the app, replacing the Google Charts loader
      window.addEventListener("DOMContentLoaded", loadData);
    </script>
  </body>
</html>
